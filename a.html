<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä»£ç†èŠ‚ç‚¹è®¢é˜…å¤„ç†å™¨ - å¤šåè®®æ”¯æŒ | æ™ºèƒ½å»é‡ | è¿é€šæ€§æµ‹è¯• | IPåœ°ç†ä½ç½®æ ‡æ³¨</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 28px;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 14px;
            opacity: 0.9;
        }

        .main-content {
            padding: 30px;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
        }

        .tab {
            padding: 12px 24px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 15px;
            color: #666;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
        }

        .tab:hover {
            color: #667eea;
        }

        .tab.active {
            color: #667eea;
            border-bottom-color: #667eea;
            font-weight: 600;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .input-group {
            margin-bottom: 20px;
        }

        .input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }

        .input-group textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            font-family: 'Courier New', monospace;
            resize: vertical;
            transition: border-color 0.3s;
        }

        .input-group textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .input-group input[type="text"] {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        .input-group input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            padding: 12px 30px;
            border: none;
            border-radius: 8px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin-right: 10px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #f0f0f0;
            color: #333;
        }

        .btn-secondary:hover {
            background: #e0e0e0;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .log-container {
            margin-top: 30px;
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            max-height: 400px;
            overflow-y: auto;
        }

        .log-container h3 {
            margin-bottom: 15px;
            color: #333;
        }

        .log-item {
            padding: 8px 12px;
            margin-bottom: 5px;
            border-radius: 4px;
            font-size: 13px;
            font-family: 'Courier New', monospace;
        }

        .log-info {
            background: #e3f2fd;
            color: #1976d2;
        }

        .log-success {
            background: #e8f5e9;
            color: #388e3c;
        }

        .log-error {
            background: #ffebee;
            color: #d32f2f;
        }

        .log-warning {
            background: #fff3e0;
            color: #f57c00;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-card h4 {
            font-size: 14px;
            opacity: 0.9;
            margin-bottom: 8px;
        }

        .stat-card p {
            font-size: 28px;
            font-weight: 700;
        }

        .result-container {
            margin-top: 30px;
        }

        .result-container h3 {
            margin-bottom: 15px;
            color: #333;
        }

        .result-box {
            background: #f8f9fa;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            max-height: 300px;
            overflow-y: auto;
            word-break: break-all;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: #e0e0e0;
            border-radius: 3px;
            overflow: hidden;
            margin-top: 20px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.3s;
        }

        .checkbox-group {
            margin-bottom: 20px;
        }

        .checkbox-group label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            margin-bottom: 10px;
        }

        .checkbox-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .spinner {
            display: inline-block;
            width: 14px;
            height: 14px;
            border: 2px solid rgba(255,255,255,0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 0.6s linear infinite;
            margin-left: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸš€ ä»£ç†èŠ‚ç‚¹è®¢é˜…å¤„ç†å™¨</h1>
            <p>å¤šåè®®æ”¯æŒ | æ™ºèƒ½å»é‡ | è¿é€šæ€§æµ‹è¯• | IPåœ°ç†ä½ç½®æ ‡æ³¨ | åŸç”ŸIPæ£€æµ‹ | DoHè§£æ | IPv6æ”¯æŒ</p>
        </div>

        <div class="main-content">
            <div class="tabs">
                <button class="tab active" data-tab="url">è®¢é˜…é“¾æ¥</button>
                <button class="tab" data-tab="content">è®¢é˜…å†…å®¹</button>
                <button class="tab" data-tab="nodes">èŠ‚ç‚¹åŸæ–‡</button>
            </div>

            <div class="tab-content active" id="url-tab">
                <div class="input-group">
                    <label>ğŸ“‹ è®¢é˜…é“¾æ¥ï¼ˆæ¯è¡Œä¸€ä¸ªï¼Œæ”¯æŒæ‰¹é‡ï¼‰</label>
                    <textarea id="url-input" rows="8" placeholder="https://example.com/sub1&#10;https://example.com/sub2&#10;https://example.com/sub3"></textarea>
                </div>
            </div>

            <div class="tab-content" id="content-tab">
                <div class="input-group">
                    <label>ğŸ“„ è®¢é˜…å†…å®¹ï¼ˆBase64ç¼–ç æˆ–åŸæ–‡ï¼Œæ”¯æŒæ‰¹é‡ï¼‰</label>
                    <textarea id="content-input" rows="8" placeholder="ç²˜è´´è®¢é˜…å†…å®¹ï¼ˆBase64ç¼–ç æˆ–èŠ‚ç‚¹åŸæ–‡ï¼‰"></textarea>
                </div>
            </div>

            <div class="tab-content" id="nodes-tab">
                <div class="input-group">
                    <label>ğŸ”— èŠ‚ç‚¹åŸæ–‡ï¼ˆæ¯è¡Œä¸€ä¸ªï¼Œæ”¯æŒæ‰¹é‡ï¼‰</label>
                    <textarea id="nodes-input" rows="8" placeholder="ss://...&#10;vmess://...&#10;trojan://..."></textarea>
                </div>
            </div>

            <div class="checkbox-group">
                <label>
                    <input type="checkbox" id="check-connectivity" checked>
                    <span>å¯ç”¨è¿é€šæ€§æµ‹è¯•ï¼ˆTCP Pingï¼Œ1ç§’è¶…æ—¶ï¼‰</span>
                </label>
                <label>
                    <input type="checkbox" id="update-labels" checked>
                    <span>æ›´æ–°èŠ‚ç‚¹æ ‡ç­¾ï¼ˆIPåœ°ç†ä½ç½®æ ‡æ³¨ï¼‰</span>
                </label>
                <label>
                    <input type="checkbox" id="deduplicate" checked>
                    <span>æ™ºèƒ½å»é‡</span>
                </label>
            </div>

            <div>
                <button class="btn btn-primary" id="process-btn">
                    <span id="btn-text">ğŸš€ å¼€å§‹å¤„ç†</span>
                </button>
                <button class="btn btn-secondary" id="clear-btn">ğŸ—‘ï¸ æ¸…ç©º</button>
                <button class="btn btn-secondary" id="copy-btn" style="display:none;">ğŸ“‹ å¤åˆ¶ç»“æœ</button>
                <button class="btn btn-secondary" id="download-btn" style="display:none;">ğŸ’¾ ä¸‹è½½è®¢é˜…</button>
            </div>

            <div class="progress-bar" id="progress-bar" style="display:none;">
                <div class="progress-fill" id="progress-fill"></div>
            </div>

            <div class="stats" id="stats" style="display:none;">
                <div class="stat-card">
                    <h4>æ€»èŠ‚ç‚¹æ•°</h4>
                    <p id="stat-total">0</p>
                </div>
                <div class="stat-card">
                    <h4>å¯ç”¨èŠ‚ç‚¹</h4>
                    <p id="stat-alive">0</p>
                </div>
                <div class="stat-card">
                    <h4>ä¸å¯ç”¨èŠ‚ç‚¹</h4>
                    <p id="stat-dead">0</p>
                </div>
                <div class="stat-card">
                    <h4>å¯ç”¨ç‡</h4>
                    <p id="stat-rate">0%</p>
                </div>
            </div>

            <div class="log-container" id="log-container" style="display:none;">
                <h3>ğŸ“Š å¤„ç†æ—¥å¿—</h3>
                <div id="log-content"></div>
            </div>

            <div class="result-container" id="result-container" style="display:none;">
                <h3>âœ… å¤„ç†ç»“æœï¼ˆBase64ç¼–ç ï¼‰</h3>
                <div class="result-box" id="result-box"></div>
            </div>
        </div>
    </div>

    <script>
        const tabs = document.querySelectorAll('.tab');
        const tabContents = document.querySelectorAll('.tab-content');
        const processBtn = document.getElementById('process-btn');
        const clearBtn = document.getElementById('clear-btn');
        const copyBtn = document.getElementById('copy-btn');
        const downloadBtn = document.getElementById('download-btn');
        const logContainer = document.getElementById('log-container');
        const logContent = document.getElementById('log-content');
        const resultContainer = document.getElementById('result-container');
        const resultBox = document.getElementById('result-box');
        const statsDiv = document.getElementById('stats');
        const progressBar = document.getElementById('progress-bar');
        const progressFill = document.getElementById('progress-fill');

        let currentTab = 'url';
        let processedNodes = [];

        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                tabs.forEach(t => t.classList.remove('active'));
                tabContents.forEach(tc => tc.classList.remove('active'));
                
                tab.classList.add('active');
                currentTab = tab.dataset.tab;
                document.getElementById(`${currentTab}-tab`).classList.add('active');
            });
        });

        function log(message, type = 'info') {
            const logItem = document.createElement('div');
            logItem.className = `log-item log-${type}`;
            logItem.textContent = message;
            logContent.appendChild(logItem);
            logContent.scrollTop = logContent.scrollHeight;
        }

        function clearLogs() {
            logContent.innerHTML = '';
            logContainer.style.display = 'none';
            resultContainer.style.display = 'none';
            statsDiv.style.display = 'none';
            progressBar.style.display = 'none';
            copyBtn.style.display = 'none';
            downloadBtn.style.display = 'none';
        }

        function updateStats(total, alive, dead) {
            document.getElementById('stat-total').textContent = total;
            document.getElementById('stat-alive').textContent = alive;
            document.getElementById('stat-dead').textContent = dead;
            const rate = total > 0 ? ((alive / total) * 100).toFixed(1) : 0;
            document.getElementById('stat-rate').textContent = rate + '%';
            statsDiv.style.display = 'grid';
        }

        function updateProgress(current, total) {
            const percent = (current / total) * 100;
            progressFill.style.width = percent + '%';
        }

        function isBase64(str) {
            try {
                return btoa(atob(str)) === str;
            } catch (err) {
                return false;
            }
        }

        function decodeBase64(str) {
            try {
                return atob(str);
            } catch (err) {
                return null;
            }
        }

        function encodeBase64(str) {
            return btoa(str);
        }

        function isValidNode(line) {
            const excludedProtocols = ['http://', 'https://', 'tcp://', 'udp://', 'ftp://', 'ftps://', 'ws://', 'wss://', 'file://', 'data://', 'mailto:', 'tel:'];
            const lineLower = line.toLowerCase();
            
            if (excludedProtocols.some(proto => lineLower.startsWith(proto))) {
                return false;
            }
            
            const pattern = /^[a-zA-Z0-9\-_]{2,10}:\/\/.+/;
            return pattern.test(line);
        }

        function extractNodesFromContent(content) {
            const nodes = [];
            
            if (!content) return nodes;
            
            if (isBase64(content)) {
                const decoded = decodeBase64(content);
                if (decoded) {
                    const lines = decoded.split('\n');
                    for (const line of lines) {
                        const trimmed = line.trim();
                        if (trimmed && isValidNode(trimmed)) {
                            nodes.push(trimmed);
                        }
                    }
                    if (nodes.length > 0) return nodes;
                }
            }
            
            const lines = content.split('\n');
            for (const line of lines) {
                const trimmed = line.trim();
                
                if (!trimmed || trimmed.startsWith('#') || trimmed.startsWith('//')) {
                    continue;
                }
                
                if (isValidNode(trimmed)) {
                    nodes.push(trimmed);
                } else if (isBase64(trimmed) && trimmed.length > 20) {
                    const decoded = decodeBase64(trimmed);
                    if (decoded) {
                        const decodedLines = decoded.split('\n');
                        for (const decodedLine of decodedLines) {
                            const decodedTrimmed = decodedLine.trim();
                            if (decodedTrimmed && isValidNode(decodedTrimmed)) {
                                nodes.push(decodedTrimmed);
                            }
                        }
                    }
                }
            }
            
            return nodes;
        }

        async function downloadSubscription(url) {
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const content = await response.text();
                return content.trim();
            } catch (err) {
                throw new Error(`ä¸‹è½½å¤±è´¥: ${err.message}`);
            }
        }

        function parseNodeAddress(nodeUrl) {
            try {
                if (nodeUrl.startsWith('ss://') || nodeUrl.startsWith('shadowsocks://')) {
                    const parts = nodeUrl.split('://')[1].split('#')[0].split('@');
                    if (parts.length === 2) {
                        const serverInfo = parts[1].split(':');
                        if (serverInfo.length >= 2) {
                            const host = serverInfo[0].replace(/[\[\]]/g, '');
                            const port = parseInt(serverInfo[1].split('?')[0].split('/')[0]);
                            return { host, port };
                        }
                    } else {
                        const decoded = decodeBase64(parts[0].split('#')[0]);
                        if (decoded && decoded.includes('@')) {
                            const serverInfo = decoded.split('@')[1].split(':');
                            if (serverInfo.length >= 2) {
                                const host = serverInfo[0].replace(/[\[\]]/g, '');
                                const port = parseInt(serverInfo[1]);
                                return { host, port };
                            }
                        }
                    }
                } else if (nodeUrl.startsWith('vmess://')) {
                    const vmessData = nodeUrl.substring(8).split('#')[0];
                    const decoded = decodeBase64(vmessData);
                    if (decoded) {
                        const config = JSON.parse(decoded);
                        const host = (config.add || '').replace(/[\[\]]/g, '');
                        const port = parseInt(config.port || 0);
                        return { host, port };
                    }
                } else {
                    const url = new URL(nodeUrl);
                    const host = url.hostname;
                    const port = parseInt(url.port);
                    if (host && port) {
                        return { host, port };
                    }
                }
            } catch (err) {
                // ignore
            }
            return null;
        }

        function isIPv6(host) {
            const ipv6Pattern = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
            return ipv6Pattern.test(host);
        }

        function isIPv4(host) {
            const ipv4Pattern = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
            return ipv4Pattern.test(host);
        }

        function isDomain(host) {
            return !isIPv4(host) && !isIPv6(host);
        }

        async function resolveDomainToIP(host) {
            try {
                const response = await fetch(`https://dns.google/resolve?name=${host}&type=A`);
                const data = await response.json();
                if (data.Answer && data.Answer.length > 0) {
                    for (const answer of data.Answer) {
                        if (answer.type === 1) {
                            return answer.data;
                        }
                    }
                }
            } catch (err) {
                // ignore
            }
            return null;
        }

        async function queryIPInfo(ip, retries = 3) {
            const cleanIP = ip.replace(/[\[\]]/g, '');
            
            for (let i = 0; i < retries; i++) {
                try {
                    const response = await fetch(`https://ipgeo-api.hf.space/${cleanIP}`);
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    const data = await response.json();
                    return data;
                } catch (err) {
                    if (i === retries - 1) {
                        return null;
                    }
                    await new Promise(resolve => setTimeout(resolve, 2000));
                }
            }
            return null;
        }

        function getCountryEmoji(countryCode) {
            if (!countryCode || countryCode.length !== 2) return 'ğŸŒ';
            const codePoints = countryCode.toUpperCase().split('').map(char => 127397 + char.charCodeAt());
            return String.fromCodePoint(...codePoints);
        }

        function generateNodeLabel(ipInfo, ip) {
            if (!ipInfo) return `ğŸŒ|Unknown-${ip}`;
            
            const parts = [];
            
            const countryCode = ipInfo.country?.code || '';
            const countryName = ipInfo.country?.name || '';
            
            if (countryCode) {
                parts.push(getCountryEmoji(countryCode));
            }
            
            if (countryName) {
                parts.push(countryName);
            }
            
            const asInfo = ipInfo.as?.info || ipInfo.as?.name || '';
            if (asInfo) {
                parts.push(asInfo);
            }
            
            const regionsShort = ipInfo.regions_short || [];
            if (regionsShort.length > 0) {
                parts.push(regionsShort.join('-'));
            }
            
            const ipType = ipInfo.type || '';
            if (ipType) {
                parts.push(ipType);
            }
            
            const registeredCountry = ipInfo.registered_country?.code || '';
            const countryCodeCheck = ipInfo.country?.code || '';
            
            if (registeredCountry && countryCodeCheck) {
                if (registeredCountry === countryCodeCheck) {
                    parts.push('åŸç”ŸIP');
                } else {
                    parts.push('å¹¿æ’­IP');
                }
            }
            
            return parts.length > 0 ? parts.join('|') : `ğŸŒ|Unknown-${ip}`;
        }

        function updateNodeLabel(nodeUrl, newLabel) {
            const urlWithoutLabel = nodeUrl.split('#')[0];
            const encodedLabel = encodeURIComponent(newLabel);
            return `${urlWithoutLabel}#${encodedLabel}`;
        }

        async function tcpPing(host, port, timeout = 1000) {
            return new Promise((resolve) => {
                const ws = new WebSocket(`wss://${host}:${port}`);
                const timer = setTimeout(() => {
                    ws.close();
                    resolve(false);
                }, timeout);
                
                ws.onopen = () => {
                    clearTimeout(timer);
                    ws.close();
                    resolve(true);
                };
                
                ws.onerror = () => {
                    clearTimeout(timer);
                    resolve(false);
                };
            });
        }

        async function checkNode(nodeUrl, checkConnectivity, updateLabel) {
            const addressInfo = parseNodeAddress(nodeUrl);
            
            if (!addressInfo) {
                return { success: false, message: 'æ— æ³•è§£æåœ°å€' };
            }
            
            const { host, port } = addressInfo;
            
            if (checkConnectivity) {
                const isAlive = await tcpPing(host, port);
                if (!isAlive) {
                    return { success: false, message: `âœ— ${host}:${port} - è¿æ¥è¶…æ—¶` };
                }
            }
            
            let updatedNode = nodeUrl;
            let message = `âœ“ ${host}:${port}`;
            
            if (updateLabel) {
                let queryIP = null;
                
                if (isDomain(host)) {
                    const resolvedIP = await resolveDomainToIP(host);
                    if (resolvedIP) {
                        queryIP = resolvedIP;
                    } else {
                        return { success: false, message: `âœ— ${host}:${port} - åŸŸåè§£æå¤±è´¥` };
                    }
                } else {
                    queryIP = host.replace(/[\[\]]/g, '');
                }
                
                const ipInfo = await queryIPInfo(queryIP);
                const newLabel = generateNodeLabel(ipInfo, queryIP);
                updatedNode = updateNodeLabel(nodeUrl, newLabel);
                message = `âœ“ ${host}:${port} -> ${newLabel}`;
            }
            
            return { success: true, node: updatedNode, message };
        }

        async function processNodes() {
            clearLogs();
            logContainer.style.display = 'block';
            progressBar.style.display = 'block';
            
            const checkConnectivity = document.getElementById('check-connectivity').checked;
            const updateLabels = document.getElementById('update-labels').checked;
            const deduplicate = document.getElementById('deduplicate').checked;
            
            processBtn.disabled = true;
            document.getElementById('btn-text').innerHTML = 'å¤„ç†ä¸­... <span class="spinner"></span>';
            
            let allNodes = [];
            
            try {
                if (currentTab === 'url') {
                    const urls = document.getElementById('url-input').value.trim().split('\n').filter(u => u.trim());
                    
                    if (urls.length === 0) {
                        log('è¯·è¾“å…¥è®¢é˜…é“¾æ¥', 'error');
                        return;
                    }
                    
                    log(`ğŸ“‹ åŠ è½½äº† ${urls.length} ä¸ªè®¢é˜…æº`, 'info');
                    
                    for (let i = 0; i < urls.length; i++) {
                        const url = urls[i].trim();
                        log(`[${i + 1}/${urls.length}] ä¸‹è½½: ${url}`, 'info');
                        
                        try {
                            const content = await downloadSubscription(url);
                            const nodes = extractNodesFromContent(content);
                            
                            if (nodes.length > 0) {
                                log(`âœ“ æ‰¾åˆ° ${nodes.length} ä¸ªèŠ‚ç‚¹`, 'success');
                                allNodes.push(...nodes);
                            } else {
                                log('- æœªæ‰¾åˆ°èŠ‚ç‚¹', 'warning');
                            }
                        } catch (err) {
                            log(`âœ— ${err.message}`, 'error');
                        }
                    }
                } else if (currentTab === 'content') {
                    const content = document.getElementById('content-input').value.trim();
                    
                    if (!content) {
                        log('è¯·è¾“å…¥è®¢é˜…å†…å®¹', 'error');
                        return;
                    }
                    
                    log('ğŸ“„ è§£æè®¢é˜…å†…å®¹...', 'info');
                    const nodes = extractNodesFromContent(content);
                    
                    if (nodes.length > 0) {
                        log(`âœ“ æ‰¾åˆ° ${nodes.length} ä¸ªèŠ‚ç‚¹`, 'success');
                        allNodes.push(...nodes);
                    } else {
                        log('âœ— æœªæ‰¾åˆ°æœ‰æ•ˆèŠ‚ç‚¹', 'error');
                        return;
                    }
                } else if (currentTab === 'nodes') {
                    const nodesText = document.getElementById('nodes-input').value.trim();
                    
                    if (!nodesText) {
                        log('è¯·è¾“å…¥èŠ‚ç‚¹åŸæ–‡', 'error');
                        return;
                    }
                    
                    log('ğŸ”— è§£æèŠ‚ç‚¹åŸæ–‡...', 'info');
                    const lines = nodesText.split('\n');
                    
                    for (const line of lines) {
                        const trimmed = line.trim();
                        if (trimmed && isValidNode(trimmed)) {
                            allNodes.push(trimmed);
                        }
                    }
                    
                    if (allNodes.length > 0) {
                        log(`âœ“ æ‰¾åˆ° ${allNodes.length} ä¸ªèŠ‚ç‚¹`, 'success');
                    } else {
                        log('âœ— æœªæ‰¾åˆ°æœ‰æ•ˆèŠ‚ç‚¹', 'error');
                        return;
                    }
                }
                
                log('='.repeat(60), 'info');
                log('èŠ‚ç‚¹æå–å®Œæˆï¼Œå¼€å§‹å¤„ç†...', 'info');
                log('='.repeat(60), 'info');
                
                let uniqueNodes = allNodes;
                if (deduplicate) {
                    uniqueNodes = [...new Set(allNodes)];
                    log(`ğŸ“Š æ€»èŠ‚ç‚¹æ•°: ${allNodes.length}`, 'info');
                    log(`ğŸ“Š å»é‡åèŠ‚ç‚¹æ•°: ${uniqueNodes.length}`, 'info');
                } else {
                    log(`ğŸ“Š æ€»èŠ‚ç‚¹æ•°: ${uniqueNodes.length}`, 'info');
                }
                
                if (checkConnectivity || updateLabels) {
                    log('ğŸ” å¼€å§‹æµ‹è¯•å’Œæ›´æ–°æ ‡ç­¾...', 'info');
                }
                
                const aliveNodes = [];
                let deadCount = 0;
                
                for (let i = 0; i < uniqueNodes.length; i++) {
                    const node = uniqueNodes[i];
                    updateProgress(i + 1, uniqueNodes.length);
                    
                    if (!checkConnectivity && !updateLabels) {
                        aliveNodes.push(node);
                        log(`[${i + 1}/${uniqueNodes.length}] âœ“ ${node.substring(0, 50)}...`, 'success');
                    } else {
                        const result = await checkNode(node, checkConnectivity, updateLabels);
                        
                        if (result.success) {
                            aliveNodes.push(result.node);
                            log(`[${i + 1}/${uniqueNodes.length}] ${result.message}`, 'success');
                        } else {
                            deadCount++;
                            log(`[${i + 1}/${uniqueNodes.length}] ${result.message}`, 'error');
                        }
                    }
                }
                
                log('='.repeat(60), 'info');
                log('å¤„ç†å®Œæˆ', 'info');
                log('='.repeat(60), 'info');
                
                updateStats(uniqueNodes.length, aliveNodes.length, deadCount);
                
                if (aliveNodes.length > 0) {
                    const mergedContent = aliveNodes.join('\n');
                    const encodedContent = encodeBase64(mergedContent);
                    
                    resultBox.textContent = encodedContent;
                    resultContainer.style.display = 'block';
                    copyBtn.style.display = 'inline-block';
                    downloadBtn.style.display = 'inline-block';
                    
                    processedNodes = aliveNodes;
                    
                    log(`âœ… å·²ç”Ÿæˆ ${aliveNodes.length} ä¸ªå¯ç”¨èŠ‚ç‚¹`, 'success');
                    log(`ğŸ“ æ–‡ä»¶å¤§å°: ${encodedContent.length} å­—èŠ‚`, 'info');
                } else {
                    log('âš ï¸ æ²¡æœ‰å¯ç”¨çš„èŠ‚ç‚¹', 'warning');
                }
                
            } catch (err) {
                log(`âŒ å¤„ç†å‡ºé”™: ${err.message}`, 'error');
                console.error(err);
            } finally {
                processBtn.disabled = false;
                document.getElementById('btn-text').textContent = 'ğŸš€ å¼€å§‹å¤„ç†';
                progressBar.style.display = 'none';
            }
        }

        clearBtn.addEventListener('click', () => {
            document.getElementById('url-input').value = '';
            document.getElementById('content-input').value = '';
            document.getElementById('nodes-input').value = '';
            clearLogs();
            processedNodes = [];
        });

        processBtn.addEventListener('click', processNodes);

        copyBtn.addEventListener('click', () => {
            const text = resultBox.textContent;
            navigator.clipboard.writeText(text).then(() => {
                const originalText = copyBtn.textContent;
                copyBtn.textContent = 'âœ… å·²å¤åˆ¶';
                setTimeout(() => {
                    copyBtn.textContent = originalText;
                }, 2000);
            }).catch(err => {
                log('å¤åˆ¶å¤±è´¥: ' + err.message, 'error');
            });
        });

        downloadBtn.addEventListener('click', () => {
            const text = resultBox.textContent;
            const blob = new Blob([text], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'subscription.txt';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            log('âœ… è®¢é˜…æ–‡ä»¶å·²ä¸‹è½½', 'success');
        });
    </script>
</body>
</html>
